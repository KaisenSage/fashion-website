/**
 * Upload existing product images (remote or local) to Cloudflare Images and rewrite products.json
 *
 * Usage:
 *   - Create .env.local with CLOUDFLARE_ACCOUNT_ID and CLOUDFLARE_API_TOKEN (see instructions below)
 *   - Ensure prisma/fixtures/products.json exists (generated by generator or your own)
 *   - node prisma/fixtures/upload-to-cloudflare.js
 *
 * What it does:
 *   - Reads products.json, iterates products and their images array
 *   - For each image URL:
 *     - If URL is an HTTP(S) remote URL, it downloads the bytes then uploads them to Cloudflare Images
 *     - If URL starts with "file:" or is a local path, it reads the file and uploads
 *   - Replaces the product images array with the Cloudflare variant URL returned by Cloudflare (first variant)
 *   - Writes a new file products.cloudflare.json (keeps original safe) and replaces products.json if you prefer
 *
 * NOTE: This will upload up to N images; be careful with rate limits and your Cloudflare plan.
 * Keep CLOUDFLARE_API_TOKEN secret and DO NOT commit it.
 */

const fs = require("fs");
const path = require("path");
const fetch = require("node-fetch"); // Node 18+ has global fetch; if your node supports global fetch remove this import
const FormData = require("form-data");
require("dotenv").config();

const ACCOUNT_ID = process.env.CLOUDFLARE_ACCOUNT_ID;
const API_TOKEN = process.env.CLOUDFLARE_API_TOKEN;
if (!ACCOUNT_ID || !API_TOKEN) {
  console.error("Missing CLOUDFLARE_ACCOUNT_ID or CLOUDFLARE_API_TOKEN in environment (.env.local).");
  process.exit(1);
}

const fixturesPath = path.join(__dirname, "products.json");
if (!fs.existsSync(fixturesPath)) {
  console.error("products.json not found at prisma/fixtures/products.json");
  process.exit(1);
}

const products = JSON.parse(fs.readFileSync(fixturesPath, "utf8"));

async function downloadBuffer(url) {
  // supports http(s) remote urls
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Failed to download ${url}: ${res.status}`);
  return await res.arrayBuffer();
}

async function uploadBufferToCloudflare(buffer, filename) {
  // POST to: https://api.cloudflare.com/client/v4/accounts/{accountIdentifier}/images/v1
  const endpoint = `https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/images/v1`;
  const form = new FormData();
  form.append("file", Buffer.from(buffer), { filename: filename || "upload.jpg" });
  // optional: set 'requireSignedURLs' or metadata attributes if needed: form.append('metadata', JSON.stringify({foo: 'bar'}));
  const res = await fetch(endpoint, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${API_TOKEN}`,
      // Node fetch will set form headers automatically
    },
    body: form,
  });
  const json = await res.json();
  if (!res.ok || !json?.result) {
    throw new Error(`Cloudflare upload failed: ${JSON.stringify(json)}`);
  }
  // json.result contains id and variants array
  return json.result;
}

(async () => {
  console.log(`Uploading product images to Cloudflare for ${products.length} products...`);
  const output = [];
  for (let i = 0; i < products.length; i++) {
    const p = products[i];
    console.log(`[${i + 1}/${products.length}] ${p.slug} â€” ${p.images?.length || 0} images`);
    const uploadedImages = [];
    if (!p.images || p.images.length === 0) {
      output.push({ ...p, images: [] });
      continue;
    }
    for (let j = 0; j < p.images.length; j++) {
      const img = p.images[j];
      try {
        let buffer;
        let filename = `${p.slug}-${j + 1}.jpg`;
        if (typeof img === "string" && img.startsWith("http")) {
          const ab = await downloadBuffer(img);
          buffer = Buffer.from(ab);
        } else {
          // treat as local path relative to repo root or absolute
          const localPath = img.replace(/^file:\/\//, "");
          if (!fs.existsSync(localPath)) {
            console.warn("Local image not found:", localPath);
            continue;
          }
          buffer = fs.readFileSync(localPath);
          filename = path.basename(localPath);
        }

        const result = await uploadBufferToCloudflare(buffer, filename);
        // Use the first variant (Cloudflare returns variants array like https://imagedelivery.net/{acct}/{id}/public)
        const variant = (result.variants && result.variants[0]) || `https://imagedelivery.net/${result.id}/public`;
        uploadedImages.push(variant);
        // optional: sleep briefly to avoid rate-limits
        await new Promise((r) => setTimeout(r, 300));
      } catch (err) {
        console.error("Upload error for", img, err?.message || err);
      }
    }

    output.push({ ...p, images: uploadedImages.length ? uploadedImages : p.images });
  }

  const outFile = path.join(__dirname, "products.cloudflare.json");
  fs.writeFileSync(outFile, JSON.stringify(output, null, 2), "utf8");
  console.log("Written", outFile);
  console.log("If satisfied, replace products.json with products.cloudflare.json or use products.cloudflare.json in your seed script.");
})();